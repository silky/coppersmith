object MultiwayJoinGenerator {
  case class Joined(code: String)
  case class IncompleteJoin(code: String)
  case class Binder(code: String)
  case class Binding(code: String)
  case class LevelJoinType(code: String)
  case class JoinTypeBinding(code: String)
  case class Lift(methodSignature: String, memoryImpl: String, scaldingImpl: String)
  case class JoinPermutation(joinTypeBinding: JoinTypeBinding, lift: Lift)

  case class GeneratedJoinLevel(
    joined:           Joined,
    nextIncomplete:   Option[IncompleteJoin],
    binding:          Binding,
    binder:           Binder,
    joinType:         LevelJoinType,
    joinPermutations: List[JoinPermutation]
  )

  def generateJoinCode(supportedDepth: Int): List[GeneratedJoinLevel] = {
    2.to(supportedDepth).foldRight(List[GeneratedJoinLevel]())((level, generated) => {

      val joined = Joined(genJoined(level, supportedDepth))
      val incompleteJoin = genIncompleteJoin(level, supportedDepth).map(IncompleteJoin(_))
      val binding = Binding(genBinding(level))
      val binder = Binder(genBinder(level))
      val joinType = LevelJoinType(genJoinType(level))

      val joinPermutations = permute(joinTypes, level - 1).map(permutation => {

        val joinTypeBinding = JoinTypeBinding(genJoinTypeBinding(level, permutation))
        val lift = genLiftMethodSig(level, permutation, "P")
        val liftMemory = genLiftMemory(level, permutation)
        val liftScalding = genLiftScalding(level, permutation)

        JoinPermutation(joinTypeBinding, Lift(lift, liftMemory, liftScalding))

      })
      GeneratedJoinLevel(joined, incompleteJoin, binding, binder, joinType, joinPermutations) :: generated
    })
  }

  // 1234...
  def numbersTo(level: Int): String = 1.to(level).mkString

  // S123...
  def sourceTypeParam(level: Int): String = "S" + numbersTo(level)

  // S1, S2, S3, ...
  def sourceTypeParamsList(level: Int): List[String] = 1.to(level).map(l => s"S$l").toList

  // T1, T2, T3, ...
  def joinedSourceParamsList(level: Int): List[String] = 1.to(level).map(l => s"T$l").toList

  // J1, J2, J3, ...
  def joinTypeParamsList(level: Int) = 1.to(level - 1).map(l => s"J$l")

  // (Inner, Inner, Inner), (Inner, Inner, Outer), (Inner, Outer, Inner), (Inner, Outer, Outer), ...
  def permute[T](values: List[T], level: Int, acc: List[T] = Nil): List[List[T]] =
    if (level == 0) List(acc)
    else values.flatMap(v => permute(values, level - 1, v :: acc))

  case class NameType(name: String, typ: String)

  sealed abstract class JoinType(val camelName: String)
  case object Inner extends JoinType("Inner")
  case object Left  extends JoinType("Left")

  def joinTypes = List[JoinType](Inner, Left)

  def joinFunctions(level: Int, start: Int = 2): List[NameType] =
    start.to(level).foldRight(List[NameType]())((l, nameTypes) => {
      val joinedSourceSoFar = joinedSourceParamsList(l - 1).mkString("(", ", ", ")")
      //                   eg, s123j3                        eg,  (T1, T2, T3) => J3
      val soFar = NameType(s"s${numbersTo(l - 1)}j${l - 1}", s"${joinedSourceSoFar} => J${l - 1}")
      //                  eg, s4j3           eg, S4 => J3
      val next = NameType(s"s${l}j${l - 1}", s"S${l} => J${l - 1}")
      soFar :: next :: nameTypes
    })

  // S1, Option[S2], S3, ...
  def joinedSourceTypes(level: Int, permutation: List[JoinType], start: Int = 2): String =
    (
      "S1" :: permutation.zipWithIndex.map {
        case (Inner, idx) => s"S${idx + 2}"
        case (Left, idx) => s"Option[S${idx + 2}]"
      }
    ).mkString(", ")

  val prelude =
    """/*
    | * Generated file, do not modify.
    | *
    | * File generated by https://github.com/CommBank/coppersmith/project/MultiwayJoinGenerator.scala
    | */
    |""".stripMargin

  def generateJoined(joins: List[GeneratedJoinLevel]): String = {
    val content = joins.map(join =>
      join.joined.code + "\n" + join.nextIncomplete.map(_.code).getOrElse("")
    ).mkString("\n\n")
    prelude + s"""
      |package commbank.coppersmith.generated
      |
      |import commbank.coppersmith.FeatureSource
      |
      |${content}
      |""".stripMargin
  }

  def genJoined(level: Int, supportedDepth: Int): String = {
    val srcTypeParams = sourceTypeParamsList(level).mkString(", ")
    val srcTypeParam = joinedSourceParamsList(level).mkString("(", ", ", ")")
    val nextSrcTypeParams = sourceTypeParamsList(level + 1).mkString(", ")
    val joinOrderingTypeParams = joinTypeParamsList(level).map(_ + " : Ordering").mkString(", ")
    val joinTypeParams = joinTypeParamsList(level).mkString(", ")
    val joinedSrcParams = joinedSourceParamsList(level).mkString(", ")
    val joinFunctionsAndTypes = joinFunctions(level).map(jf =>
      jf.name + ": " + jf.typ
    ).mkString(",\n  ")

    s"""case class Joined${level}[
      |  ${srcTypeParams},
      |  ${joinOrderingTypeParams},
      |  ${joinedSrcParams}
      |](
      |  ${joinFunctionsAndTypes},
      |  filter: Option[(${srcTypeParam}) => Boolean]
      |) extends FeatureSource[${srcTypeParam}, Joined${level}[${srcTypeParams}, ${joinTypeParams}, ${joinedSrcParams}]](filter) {
      |
      |  type FS = Joined${level}[${srcTypeParams}, ${joinTypeParams}, ${joinedSrcParams}]
      |
      |  def copyWithFilter(filter: Option[(${srcTypeParam}) => Boolean]) = copy(filter = filter)""".stripMargin +
      {
        if (level < supportedDepth) { s"""
      |
      |  def innerJoinTo[S${level + 1}] =
      |    IncompleteJoin${level + 1}[
      |      ${nextSrcTypeParams}, ${joinTypeParams}, ${joinedSrcParams}, S${level + 1}
      |    ](${joinFunctions(level).map(_.name).mkString(", ")}, filter)
      |  def inner[S${level + 1}] = innerJoinTo[S${level + 1}]
      |  def leftJoinTo[S${level + 1}] =
      |    IncompleteJoin${level + 1}[
      |      ${nextSrcTypeParams}, ${joinTypeParams}, ${joinedSrcParams}, Option[S${level + 1}]
      |    ](${joinFunctions(level).map(_.name).mkString(", ")}, filter)
      |  def left[S${level + 1}] = leftJoinTo[S${level + 1}]""".stripMargin
        } else ""
      } + """
      |}
      |""".stripMargin
  }

  def genIncompleteJoin(level: Int, supportedDepth: Int): Option[String] = {
    if (level < supportedDepth) {
      val srcTypeParam = joinedSourceParamsList(level).mkString("(", ", ", ")")
      val nextSrcTypeParams = sourceTypeParamsList(level + 1).mkString(", ")
      val joinOrderingTypeParams = joinTypeParamsList(level).map(_ + " : Ordering").mkString(", ")
      val nextJoinTypeParams = joinTypeParamsList(level + 1).mkString(", ")
      val joinedSrcParams = joinedSourceParamsList(level).mkString(", ")
      val joinFunctionsAndTypes = joinFunctions(level).map(jf =>
        jf.name + ": " + jf.typ
      ).mkString(",\n  ")
      val nextJoinFunctionsAndTypes = joinFunctions(level + 1, level + 1).map(jf =>
        jf.name + ": " + jf.typ
      ).mkString(",\n    ")
      val tupledSourceNames = 1.to(level).map(l => s"s._${l}").mkString(", ")

      Some(
        s"""case class IncompleteJoin${level + 1}[${nextSrcTypeParams}, ${joinOrderingTypeParams}, ${joinedSrcParams}, T${level + 1}](
        |  ${joinFunctionsAndTypes},
        |  filter: Option[(${srcTypeParam}) => Boolean]
        |) {
        |  def on[J${level} : Ordering](
        |    ${nextJoinFunctionsAndTypes}
        |  ): Joined${level + 1}[${nextSrcTypeParams}, ${nextJoinTypeParams}, ${joinedSourceParamsList(level + 1).mkString(", ")}] =
        |    Joined${level + 1}(${joinFunctions(level + 1).map(_.name).mkString(", ")},
        |           filter.map(f => s => f((${tupledSourceNames}))))
        |}""".stripMargin
      )
    } else None
  }

  def generateBinders(joins: List[GeneratedJoinLevel]): String = {
    val bindings = joins.map(
      _.binding.code
    ).mkString("\n\n")
    val binders = joins.map(
      _.binder.code
    ).mkString("\n\n")
    prelude + s"""
      |package commbank.coppersmith.generated
      |
      |import commbank.coppersmith.{DataSource, Lift, SourceBinder}
      |
      |trait GeneratedBindings {
      |${bindings}
      |}
      |
      |${binders}
      |""".stripMargin
  }

  def genBinding(level: Int): String = {
    val srcTypeParams = sourceTypeParamsList(level).mkString(", ")
    val joinOrderingTypeParams = joinTypeParamsList(level).map(_ + " : Ordering").mkString(", ")
    val joinedSrcParams = joinedSourceParamsList(level).mkString(", ")
    val joinTypeParams = joinTypeParamsList(level).mkString(", ")
    val sources = 1.to(level).map(l => s"s${l}: DataSource[S${l}, P]").mkString(",\n    ")
    val sourceNames = 1.to(level).map(l => s"s${l}").mkString(", ")

    s"""  def joinMulti[${srcTypeParams}, ${joinOrderingTypeParams}, ${joinedSrcParams}, P[_] : Lift](
      |    ${sources}
      |  )(implicit jt: Join${level}Type[${srcTypeParams}, ${joinedSrcParams}, P]) =
      |    Joined${level}Binder[${srcTypeParams}, ${joinTypeParams}, ${joinedSrcParams}, P]($sourceNames)""".stripMargin
  }

  def genBinder(level: Int): String = {
    val srcTypeParams = sourceTypeParamsList(level).mkString(", ")
    val joinOrderingTypeParams = joinTypeParamsList(level).map(_ + " : Ordering").mkString(", ")
    val joinedSrcParams = joinedSourceParamsList(level).mkString(", ")
    val joinTypeParams = joinTypeParamsList(level).mkString(", ")
    val sources = 1.to(level).map(l => s"s${l}: DataSource[S${l}, P]").mkString(",\n  ")
    val sourceNames = 1.to(level).map(l => s"s${l}").mkString(", ")
    val joinedType = s"Joined${level}[${srcTypeParams}, ${joinTypeParams}, ${joinedSrcParams}]"

    s"""case class Joined${level}Binder[${srcTypeParams}, ${joinOrderingTypeParams}, ${joinedSrcParams}, P[_] : Lift](
      |  ${sources}
      |)(implicit jt: Join${level}Type[${srcTypeParams}, ${joinedSrcParams}, P])
      |     extends SourceBinder[($srcTypeParams), (${joinedSrcParams}), ${joinedType}, P] {
      |  def bind(j: ${joinedType}): P[(${joinedSrcParams})] =
      |    jt.lift(j)(${sourceNames})
      |}""".stripMargin
  }

  def generateJoinTypes(joins: List[GeneratedJoinLevel]): String = {
    val joinTypes = joins.map(_.joinType.code).mkString("\n\n")
    val joinTypeBindings = joins.map(
      _.joinPermutations.map(_.joinTypeBinding.code).mkString("\n")
    ).mkString("\n\n")

    prelude + s"""
      |package commbank.coppersmith.generated
      |
      |import commbank.coppersmith.{DataSource, Lift}
      |
      |${joinTypes}
      |
      |trait GeneratedJoinTypeInstances {
      |${joinTypeBindings}
      |}
      |""".stripMargin
  }

  def genJoinType(level: Int): String = {
    val srcTypeParams = sourceTypeParamsList(level).mkString(", ")
    val joinedSrcParams = joinedSourceParamsList(level).mkString(", ")
    val joinOrderingTypeParams = joinTypeParamsList(level).map(_ + " : Ordering").mkString(", ")
    val joinTypeParams = joinTypeParamsList(level).mkString(", ")
    val sources = 1.to(level).map(l => s"s${l}: DataSource[S${l}, P]").mkString(",\n    ")
    val joinedType = s"Joined${level}[${srcTypeParams}, ${joinTypeParams}, ${joinedSrcParams}]"

    s"""sealed abstract class Join${level}Type[${srcTypeParams}, ${joinedSrcParams}, P[_] : Lift] {
      |  def lift[${joinOrderingTypeParams}](
      |    j: ${joinedType}
      |  )(${sources}
      |  ): P[(${joinedSrcParams})]
      |}""".stripMargin
  }

  def genJoinTypeBinding(level: Int, permutation: List[JoinType]): String = {
    val joinType = permutation.map(_.camelName).mkString
    val srcTypeParams = sourceTypeParamsList(level).mkString(", ")
    val joinOrderingTypeParams = joinTypeParamsList(level).map(_ + " : Ordering").mkString(", ")
    val joinTypeParams = joinTypeParamsList(level).mkString(", ")
    val joinedSrcTypes = joinedSourceTypes(level, permutation)
    val joinedReturnType = joinedSourceTypes(level, permutation, level)
    val sources = 1.to(level).map(l => s"s${l}: DataSource[S${l}, P]").mkString(",\n      ")
    val loadCalls = 1.to(level).map(l => s"s${l}.load").mkString(", ")
    val joinedType = s"Joined${level}[${srcTypeParams}, ${joinTypeParams}, ${joinedSrcTypes}]"

    s"""  implicit def type${joinType}[${srcTypeParams}, P[_]: Lift] =
      |      new Join${level}Type[${srcTypeParams}, ${joinedReturnType}, P] {
      |    def lift[${joinOrderingTypeParams}](
      |      j: ${joinedType}
      |    )(${sources}
      |    ): P[(${joinedReturnType})] =
      |      implicitly[Lift[P]].liftJoin${joinType}(j)(${loadCalls})
      |  }""".stripMargin
  }

  def generateLift(joins: List[GeneratedJoinLevel]): String = {
    val content = joins.map(
      _.joinPermutations.map(_.lift.methodSignature).mkString("\n")
    ).mkString("\n\n")

    prelude + s"""
      |package commbank.coppersmith.generated
      |
      |trait GeneratedLift[P[_]] {
      |${content}
      |}
      |""".stripMargin
  }

  def genLiftMethodSig(level: Int, permutation: List[JoinType], pType: String): String = {
    val joinType = permutation.map(_.camelName).mkString
    val srcTypeParams = sourceTypeParamsList(level).mkString(", ")
    val joinOrderingTypeParams = joinTypeParamsList(level).map(_ + " : Ordering").mkString(", ")
    val joinTypeParams = joinTypeParamsList(level).mkString(", ")
    val joinedSrcTypes = joinedSourceTypes(level, permutation)
    val joinedReturnType = joinedSourceTypes(level, permutation, level)
    val sources = 1.to(level).map(l => s"s${l}: ${pType}[S${l}]").mkString(", ")

    s"""  def liftJoin${joinType}[${srcTypeParams}, ${joinOrderingTypeParams}](
    |    joined: Joined${level}[${srcTypeParams}, ${joinTypeParams}, ${joinedSrcTypes}]
    |  )(${sources}): ${pType}[(${joinedReturnType})]""".stripMargin
  }

  def generateLiftScalding(joins: List[GeneratedJoinLevel]): String = {
    val content = joins.map(
      _.joinPermutations.map(_.lift.scaldingImpl).mkString("\n")
    ).mkString("\n\n")

    prelude + s"""
      |package commbank.coppersmith.scalding.generated
      |
      |import com.twitter.scalding.TypedPipe
      |
      |import commbank.coppersmith.generated._
      |
      |trait GeneratedScaldingLift {
      |${content}
      |}
      |""".stripMargin
  }

  def genLiftScalding(level: Int, permutation: List[JoinType]): String = {
    genLiftMethodSig(level, permutation, "TypedPipe") + " = {\n" +
      permutation.zipWithIndex.foldRight(List[String]()){ case ((jt, idx), joins) => {
        val level = idx + 1
        val joinType = jt match {
          case Inner => "join"
          case Left => "leftJoin"
        }
        val joinSrc = s"s${numbersTo(level)}"
        val nextSrc = s"s${level + 1}"
        val join = s"j${level}"
        val tupled = if (level == 1) "" else ".tupled"

        val init = if (level == 1) "    s1" else "  "

        val group = s".groupBy(joined.${joinSrc}${join}${tupled}).${joinType}(${nextSrc}.groupBy(joined.${nextSrc}${join})).values"

        val map = if (level == 1) "" else {
          val sources = 1.to(level).map(l => s"s$l").mkString(", ")
          s"\n      .map { case ((${sources}), s${level + 1}) => (${sources}, s${level + 1}) }"
        }

        (init + group + map) :: joins
      }}.mkString("", "\n    ", "\n  }")
  }

  def generateLiftMemory(joins: List[GeneratedJoinLevel]): String = {
    val content = joins.map(
      _.joinPermutations.map(_.lift.memoryImpl).mkString("\n")
    ).mkString("\n\n")

    prelude + s"""
      |package commbank.coppersmith.lift.generated
      |
      |import commbank.coppersmith.generated._
      |import commbank.coppersmith.lift.MemoryLift.{innerJoin, leftJoin}
      |
      |trait GeneratedMemoryLift {
      |${content}
      |}
      |""".stripMargin
  }

  def genLiftMemory(level: Int, permutation: List[JoinType]): String = {
    genLiftMethodSig(level, permutation, "List") + " = {\n" +
      permutation.zipWithIndex.foldRight(List[String]()){ case ((permutation, idx), joins) => {
        val level = idx + 1

        val joinType = permutation match {
          case Inner => "innerJoin"
          case Left => "leftJoin"
        }
        val joinSrc = s"s${numbersTo(level)}"
        val nextSrc = s"s${level + 1}"
        val join = s"j${level}"
        val tupled = if (level == 1) "" else ".tupled"

        val group = s"    val s${numbersTo(level + 1)} = ${joinType}(joined.${joinSrc}${join}${tupled}, joined.${nextSrc}${join}, ${joinSrc}, ${nextSrc})"

        val map = if (level == 1) "" else {
          val sources = 1.to(level).map(l => s"s$l").mkString(", ")
          s"\n      .map { case ((${sources}), s${level + 1}) => (${sources}, s${level + 1}) }"
        }

        (group + map) :: joins
      }}.mkString("", "\n    ", s"\n    s${numbersTo(level)}\n  }")
  }
}
